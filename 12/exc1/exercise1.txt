Exercise 1

a) Original Code:
unsigned c2 = 32 * c1;

Strength Reduction Transformation:
unsigned c2 = c1 << 5;

Circumstances for Transformation:
The transformation should be applied if the cost of performing the bit-shift operation is less than the cost of performing the multiplication. This is typically true in most scalar architectures, as bit-shifting is a simpler and faster operation compared to multiplication.

Assembly Code Comparison:
        mov     esi, edi
        xor     eax, eax
        mov     edi, OFFSET FLAT:.LC0
        sal     esi, 5
        jmp     printf

It uses the shift operation (sal esi, 5) instead of multiplication by 32.

Transformed version:
        mov     esi, edi
        xor     eax, eax
        mov     edi, OFFSET FLAT:.LC0
        sal     esi, 5
        jmp     printf

It uses the shift operation (sal esi, 5) instead of multiplication by 32.

Compiler Optimization Investigation:
The compiler optimized both functions a and a_solution to the same assembly code.

b) Original Code:
unsigned c2 = 15 * c1;

Strength Reduction Transformation:  
unsigned c2 = (c1 << 3) + (c1 << 2) + (c1 << 1) + c1;

Circumstances for Transformation: 
If additions and shifts are cheaper than multiplication. 

Assembly Code Comparison:
        mov     esi, edi
        xor     eax, eax
        sal     esi, 4
        sub     esi, edi
        mov     edi, OFFSET FLAT:.LC1
        jmp     printf

It replaces multiplication with shifts and subtraction.

Transformed version:
        imul    esi, edi, 15
        xor     eax, eax
        mov     edi, OFFSET FLAT:.LC1
        jmp     printf

For b_solution, the compiler uses direct multiplication.

Compiler Optimization Investigation:
The compiler with -O3 already optimizes multiplications effectively. Usually, additional manual transformations are not needed unless there are specific architectural constraints.

c) Original Code:
unsigned c2 = 96 * c1;

Strength Reduction Transformation:
unsigned c2 = (c1 << 6) + (c1 << 5);

Circumstances for Transformation:
Apply the transformation (using shifts and additions) when the cost of performing shifts and additions is lower than that of a multiplication operation.

Assembly Code Comparison:
        lea     esi, [rdi+rdi*2]
        xor     eax, eax
        mov     edi, OFFSET FLAT:.LC2
        sal     esi, 5
        jmp     printf

The compiler multiplies rdi by 3 and then multiplies it by 32 using shift and addition operations

Transformed version:
        imul    esi, edi, 96
        xor     eax, eax
        mov     edi, OFFSET FLAT:.LC0
        jmp     printf

It now directly multiplies the values .

Compiler Optimization Investigation:
The compiler with -O3 already optimizes multiplications effectively. Usually, additional manual transformations are not needed unless there are specific architectural constraints.

d) Original Code:
unsigned c2 = 0.125 * c1;

Strength Reduction Transformation:
unsigned c2 = c1 >> 3;

Circumstances for Transformation:
The transformation should be applied if the cost of performing the bit-shift operation is less than the cost of performing the multiplication.

Assembly Code Comparison:
        mov     edi, edi
        pxor    xmm0, xmm0
        xor     eax, eax
        cvtsi2sdq       xmm0, rdi
        mulsd   xmm0, QWORD PTR .LC3[rip]
        mov     edi, OFFSET FLAT:.LC4
        cvttsd2si       rsi, xmm0
        jmp     printf

It first converts the integer from rdi to a double precision floating-point and stores it in xmm0. It then ultiplies the double in xmm0 by the constant 0.125 (stored at a memory location referenced as `.LC3`). After that it converts the double precision floating-point result back to an integer.

Transformed version:
        mov     esi, edi
        xor     eax, eax
        mov     edi, OFFSET FLAT:.LC0
        shr     esi, 3
        jmp     printf

Shifts the value right by 3 bits. This effectively divides the value by 8 using a very fast bit manipulation technique.

Compiler Optimization Investigation:
The strength reduction transformation is very effective in this case because it replaces a slower, more complex floating-point multiplication with a faster, simpler integer bit shift.

e) Original Code:
unsigned sum_fifth = 0;
for (int i = 0; i < N / 5; ++i) {
    sum_fifth += a[5 * i];
}

Strength Reduction Transformation:
unsigned sum_fifth = 0;
for (int index = 0, i = 0; i < N / 5; ++i, index += 5) {
    sum_fifth += a[index];
}

Circumstances for Transformation:
We avoid multiplying 5 * i in every iteration, becasue we maintain a separate variable index that starts at 0 and increments by 5 on each loop iteration. This change transforms a multiplication into a simpler addition.

Assembly Code Comparison:
.L13:
        add     esi, DWORD PTR [rdi]
        add     rdi, 20
        cmp     rax, rdi
        jne     .L13
        mov     edi, OFFSET FLAT:.LC5
        xor     eax, eax
        jmp     printf

It first adds the value at the memory address pointed to by `rdi` to the register `esi`, which accumulates the sum. The `add rdi, 20` instruction then advances the `rdi` pointer by 20 bytes, to point to the next fifth element of the array. The `cmp rax, rdi` compares the current pointer `rdi` with `rax`, which holds the end address of the iteration. If they are not equal, the `jne .L13` instruction causes the loop to jump back to the label `.L13`, continuing the iteration. This loop continues until the entire array is processed, summing every fifth element.

Transformed version:
.L2:
        add     esi, DWORD PTR [rdi]
        add     rdi, 20
        cmp     rax, rdi
        jne     .L2
        mov     edi, OFFSET FLAT:.LC0
        xor     eax, eax
        jmp     printf

The compiler sums every fifth element of an array by incrementing the pointer by 20 bytes and continues until the end of the array is reached again.

Compiler Optimization Investigation:
The compiler optimized both functions a and d_solution to the same assembly code.


f) Original Code:
for (int i = 0; i < N; ++i) {
    a[i] += i / 5.3;
}

Strength Reduction Transformation:
to:do

Circumstances for Transformation:

to:do
Assembly Code Comparison:
to:do

Transformed version:
to:do

Compiler Optimization Investigation:
to:do

g) Original Code:
float c2 = -1 * c1;

Strength Reduction Transformation:
to:do

Circumstances for Transformation:

to:do
Assembly Code Comparison:
to:do

Transformed version:
to:do

Compiler Optimization Investigation:
to:do