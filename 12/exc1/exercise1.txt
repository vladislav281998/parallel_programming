Exercise 1

a) Original Code:
unsigned c2 = 32 * c1;

Strength Reduction Transformation:
unsigned c2 = c1 << 5;

Circumstances for Transformation:
The transformation should be applied if the cost of performing the bit-shift operation is less than the cost of performing the multiplication. This is typically true in most scalar architectures, as bit-shifting is a simpler and faster operation compared to multiplication.

Assembly Code Comparison:
        mov     esi, edi
        xor     eax, eax
        mov     edi, OFFSET FLAT:.LC0
        sal     esi, 5
        jmp     printf

It uses the shift operation (sal esi, 5) instead of multiplication by 32.

Transformed version:
        mov     esi, edi
        xor     eax, eax
        mov     edi, OFFSET FLAT:.LC0
        sal     esi, 5
        jmp     printf

It uses the shift operation (sal esi, 5) instead of multiplication by 32.

Compiler Optimization Investigation:
The compiler optimized both functions a and a_solution to the same assembly code.

b) Original Code:
unsigned c2 = 15 * c1;

Strength Reduction Transformation:  
unsigned c2 = (c1 << 3) + (c1 << 2) + (c1 << 1) + c1;

Circumstances for Transformation: 
If additions and shifts are cheaper than multiplication. 

Assembly Code Comparison:
        mov     esi, edi
        xor     eax, eax
        sal     esi, 4
        sub     esi, edi
        mov     edi, OFFSET FLAT:.LC1
        jmp     printf

It replaces multiplication with shifts and subtraction.

Transformed version:
        imul    esi, edi, 15
        xor     eax, eax
        mov     edi, OFFSET FLAT:.LC1
        jmp     printf

For b_solution, the compiler uses direct multiplication.

Compiler Optimization Investigation:
The compiler with -O3 already optimizes multiplications effectively. Usually, additional manual transformations are not needed unless there are specific architectural constraints.

c) Original Code:
unsigned c2 = 96 * c1;

Strength Reduction Transformation:
unsigned c2 = (c1 << 6) + (c1 << 5);

Circumstances for Transformation:
Apply the transformation (using shifts and additions) when the cost of performing shifts and additions is lower than that of a multiplication operation.

Assembly Code Comparison:
        lea     esi, [rdi+rdi*2]
        xor     eax, eax
        mov     edi, OFFSET FLAT:.LC2
        sal     esi, 5
        jmp     printf

The compiler multiplies rdi by 3 and then multiplies it by 32 using shift and addition operations

Transformed version:
        imul    esi, edi, 96
        xor     eax, eax
        mov     edi, OFFSET FLAT:.LC0
        jmp     printf

It now directly multiplies the values .

Compiler Optimization Investigation:
The compiler with -O3 already optimizes multiplications effectively. Usually, additional manual transformations are not needed unless there are specific architectural constraints.

d) Original Code:
unsigned c2 = 0.125 * c1;

Strength Reduction Transformation:
unsigned c2 = c1 >> 3;

Circumstances for Transformation:
The transformation should be applied if the cost of performing the bit-shift operation is less than the cost of performing the multiplication.

Assembly Code Comparison:
        mov     edi, edi
        pxor    xmm0, xmm0
        xor     eax, eax
        cvtsi2sdq       xmm0, rdi
        mulsd   xmm0, QWORD PTR .LC3[rip]
        mov     edi, OFFSET FLAT:.LC4
        cvttsd2si       rsi, xmm0
        jmp     printf

It first converts the integer from rdi to a double precision floating-point and stores it in xmm0. It then ultiplies the double in xmm0 by the constant 0.125 (stored at a memory location referenced as `.LC3`). After that it converts the double precision floating-point result back to an integer.

Transformed version:
        mov     esi, edi
        xor     eax, eax
        mov     edi, OFFSET FLAT:.LC0
        shr     esi, 3
        jmp     printf

Shifts the value right by 3 bits. This effectively divides the value by 8 using a very fast bit manipulation technique.

Compiler Optimization Investigation:
The strength reduction transformation is very effective in this case because it replaces a slower, more complex floating-point multiplication with a faster, simpler integer bit shift.

e) Original Code:
unsigned sum_fifth = 0;
for (int i = 0; i < N / 5; ++i) {
    sum_fifth += a[5 * i];
}

Strength Reduction Transformation:
unsigned sum_fifth = 0;
for (int index = 0, i = 0; i < N / 5; ++i, index += 5) {
    sum_fifth += a[index];
}

Circumstances for Transformation:
We avoid multiplying 5 * i in every iteration, becasue we maintain a separate variable index that starts at 0 and increments by 5 on each loop iteration. This change transforms a multiplication into a simpler addition.

Assembly Code Comparison:
.L13:
        add     esi, DWORD PTR [rdi]
        add     rdi, 20
        cmp     rax, rdi
        jne     .L13
        mov     edi, OFFSET FLAT:.LC5
        xor     eax, eax
        jmp     printf

It first adds the value at the memory address pointed to by `rdi` to the register `esi`, which accumulates the sum. The `add rdi, 20` instruction then advances the `rdi` pointer by 20 bytes, to point to the next fifth element of the array. The `cmp rax, rdi` compares the current pointer `rdi` with `rax`, which holds the end address of the iteration. If they are not equal, the `jne .L13` instruction causes the loop to jump back to the label `.L13`, continuing the iteration. This loop continues until the entire array is processed, summing every fifth element.

Transformed version:
.L2:
        add     esi, DWORD PTR [rdi]
        add     rdi, 20
        cmp     rax, rdi
        jne     .L2
        mov     edi, OFFSET FLAT:.LC0
        xor     eax, eax
        jmp     printf

The compiler sums every fifth element of an array by incrementing the pointer by 20 bytes and continues until the end of the array is reached again.

Compiler Optimization Investigation:
The compiler optimized both functions a and d_solution to the same assembly code.


f) original:
for (int i = 0; i < N; ++i) {
    a[i] += i / 5.3;
}
f:
        push    rbp
        mov     rax, rdi
        lea     rbp, [rdi+8000]
        push    rbx
        mov     rbx, rdi
        sub     rsp, 8
        movdqa  xmm2, XMMWORD PTR .LC6[rip]
        movdqa  xmm4, XMMWORD PTR .LC7[rip]
        movapd  xmm3, XMMWORD PTR .LC8[rip]
.L17:
        pshufd  xmm0, xmm2, 238
        cvtdq2pd        xmm1, xmm2
        movupd  xmm6, XMMWORD PTR [rax]
        add     rax, 32
        cvtdq2pd        xmm0, xmm0
        divpd   xmm1, xmm3
        movupd  xmm5, XMMWORD PTR [rax-16]
        paddd   xmm2, xmm4
        divpd   xmm0, xmm3
        addpd   xmm1, xmm6
        movups  XMMWORD PTR [rax-32], xmm1
        addpd   xmm0, xmm5
        movups  XMMWORD PTR [rax-16], xmm0
        cmp     rax, rbp
        jne     .L17
        mov     edi, OFFSET FLAT:.LC9
        xor     eax, eax
        call    printf
.L18:
        movsd   xmm0, QWORD PTR [rbx]
        mov     edi, OFFSET FLAT:.LC10
        mov     eax, 1
        add     rbx, 8
        call    printf
        cmp     rbx, rbp
        jne     .L18
        add     rsp, 8
        pop     rbx
        pop     rbp
        ret

Interpretation: The compiler optimzes the code with SIMD instructions (movupd, divpd, addpd) but still performs the division in each iteration.

strength reduced:
double multiplier = 1.0 / 5.3;
double accumulated = 0.0; 

for (int i = 0; i < N; ++i) {
    accumulated += multiplier;
    a[i] += accumulated;
}

When to apply: If the cost of performing two additions is less than performing one addition and one multiplication.

f_solution:
        push    rbp
        mov     rax, rdi
        lea     rbp, [rdi+8000]
        pxor    xmm0, xmm0
        push    rbx
        mov     rbx, rdi
        sub     rsp, 8
        movsd   xmm2, QWORD PTR .LC12[rip]
.L23:
        addsd   xmm0, xmm2
        movsd   xmm1, QWORD PTR [rax]
        add     rax, 8
        addsd   xmm1, xmm0
        movsd   QWORD PTR [rax-8], xmm1
        cmp     rbp, rax
        jne     .L23
        mov     edi, OFFSET FLAT:.LC13
        xor     eax, eax
        call    printf
.L24:
        movsd   xmm0, QWORD PTR [rbx]
        mov     edi, OFFSET FLAT:.LC10
        mov     eax, 1
        add     rbx, 8
        call    printf
        cmp     rbp, rbx
        jne     .L24
        add     rsp, 8
        pop     rbx
        pop     rbp
        ret
.LC15:
        .string "g): %u\n"

Interpretation: Due to the accumulation SIMD does not really work well here. But the divion has been removed.

g) original:
c1 is of type float:

float c2 = -1 * c1;

g:
        xorps   xmm0, XMMWORD PTR .LC14[rip]
        mov     edi, OFFSET FLAT:.LC15
        mov     eax, 1
        cvtss2sd        xmm0, xmm0
        jmp     printf

Interpretation: The compiler already recognizes that this operation is supposed to flip the sign bit. It uses xorps, which is the most efficient way to flip the sign bit.

strength reduced:
float c2;
*(uint32_t*)&c2 = *(uint32_t*)&c1 ^ (1 << 31);

g_solution:
        movd    eax, xmm0
        mov     edi, OFFSET FLAT:.LC15
        pxor    xmm0, xmm0
        add     eax, -2147483648
        mov     DWORD PTR [rsp-12], eax
        mov     eax, 1
        cvtss2sd        xmm0, DWORD PTR [rsp-12]
        jmp     printf

When to apply: If the cost of the XOR operation is less than the multiplication.
Interpretation: The reduced version introduces unnecessary operations, namely movd and cvtss2sd: These are used to move the data between integer and floating-point registers and formats, adding overhead.




