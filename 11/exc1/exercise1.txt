1. Obtain a performance profile of the given application:
-Modify the compilation flags in the Makefile to include gprof instrumentation. We need to add the `-pg` flag to the `CC_FLAGS` in the `Makefile`.
-Run the application to generate the `gmon.out` profile data with `./real`.
-Run gprof to generate the performance analysis file with `gprof real gmon.out > analysis.txt`.

2. Discussion about the performance profile, what information does it hold and how/why is this useful?
-The performance profile generated by `gprof` provides detailed insights into where the program spent most of its execution time and which functions are the most expensive.
-Displays the amount of time (in percentage and absolute values) spent on executing each function, as well as the number of times each function was called:
	1. 46.78%: The `resid` fucntion is consuming nearly half of the total execution time and gets called 147 times with a for loop that can be parallelized with omp for.
	2. 19.03%: The `psinv` fucntion also consumes almost one-fifth of the total runtime and can also be parallelized with omp for.
	3-5: ~10% The `interp`, `vranlc` and `rprj3` function all consume around 10% of time and can also be benefitly from parallelization. The function `vranlc` in `randdp.c` where each iteration of the loop depends only on the current values of the variables `x` and `y[]`, which change inside the loop, but there are no dependencies between different iterations.  Thus, this loop can be safely parallelized. `interp` and `rprj3 ` can also be partially paralyzed.
	6: 3.48% The `norm2u3` less critical, but further optimizatio can be done by partially paralyzing the function.
	-> Most of the time computation time is taken up by the wtime function. This function cant be parallelized, but since this function only gets used to measure the code this is not really significant.
-Provides information about function calls, including which functions were called, from which functions they were called, and how much time was spent on each call. This section helps to understand which functions are the most time-consuming and how they interact with each other.
	`mg3P.constprop.2` seems to be a main or governing function making calls to other important functions (resid, psinv, rprj3, interp).
-Action Plan:
	1. Parallelize High-Cost Functions: Focus on `resid` and `psinv` first as they consume the majority of the time.
	2. Profile After Optimization: After parallelizing the high-cost functions, generate new performance profiles to observe the improvement and identify additional bottlenecks.
-The performance profile helps identify where the execution time is predominantly spent and guides us to target specific functions for optimization through parallelization. This systematic approach ensures resources are focused on high-impact areas, maximizing the performance gains from parallelization.

`gprof` helps to identify functions that occupy the most execution time in the program. This allows focusing optimization efforts on these specific parts of the code.


